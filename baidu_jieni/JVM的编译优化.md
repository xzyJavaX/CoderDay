### 方法内联

从原理上来说，方法内联理解起来并不难，主要思想就是**将目标方法的内容原封不动的『复制』到发起调用的方法中执行，避免出现实际的方法调用**，因为方法调用会涉及到虚拟机栈的出栈入栈。

例如：

```java
public static void fun1() {
  int x = A.get();
  System.out.println(x);
}

public class A {
	static int val;
  public static int get() {
  	return val;
  }
}
```

对于这段代码，jvm最终并不是按这个逻辑原封不动的执行的，经过编译器的方法内联初步优化，其实际逻辑是这样的（**注意，编译器的优化是在机器码指令或者字节码上的，并非直接修改java代码**）：

```java
public static void fun1() {
	int x = A.val;
  System.out.println(x);
}

public class A {
	static int val;
  public static int get() {
  	return val;
  }
}
```

相比较优化前，减少了一次方法的调用，也就少了一次创建栈帧、入栈、出栈的过程，性能得到了一定的提升。

但在实际的Java项目中，方法与方法之间的关系、调用逻辑远比示例复杂，而且关键的一点在于，由于Java鼓励面向对象编程，类和类的继承关系、类和接口的实现关系导致Java的方法大多数都是虚方法，即一个 get() 方法可能是类A的，也可能是类A的子类B的 get() 方法，在编译阶段，编译器无法判断这种方法的实际类型。

**CHA**

为了解决这类问题，C++选择为所有的方法默认作为非虚方法。Java则是在JVM中解决。为了解决虚方法的内联问题，JVM引入了一种类型继承关系分析的机制（Class Hierarchy Analysis，CHA）。这是适用于整个程序生命周期的类型分析技术，用于确定当前已经加载的类中，**某个接口是否有多于一个的实现、某个类是否存在子类，某个子类是否重写了父类的非虚方法。**基于CHA，对于非虚方法，可以放心的进行内联，如果是虚方法，会判断当前程序状态下该虚方法是否只有一个版本的实现，那么就会激进认为整个生命周期该虚方法都是只有这一个版本去内联，但会预留『逃生门』作为兜底策略，当该虚方法有新的版本加入时，程序会退回解释阶段重新编译。

### 逃逸分析

逃逸分析是比较前沿的优化技术，和类型继承关系分析一样，并不是直接优化代码的技术，而是为其他优化提供依据的分析技术。

通过分析对象的动态作用域，一个对象在方法内定义后，没有外部引用的情况即**无逃逸**；如果它会被外部方法引用，例如作为参数传递到其他方法，那么称为**方法逃逸**；如果会被其他线程访问，例如复制给会在其他线程中访问到的实例变量，那么称为**线程逃逸**。三种类型的逃逸程度依次升高。

**栈上分配**

通常来说，Java对象会被分配在堆上，可以被所有线程共享。同时，垃圾回收器会回收堆上不在使用的对象。垃圾收集的整个流程来说都是开销很大的，无论是哪一种收集器。那么对于没有被其他线程引用的变量，将其分配到虚拟机栈，随着方法的调用入栈和出栈而被创建和销毁，而大部分变量都是不会逃逸和仅存在方法逃逸的，所以基于逃逸分析对这些变量做栈上分配可以降低垃圾收集子系统的压力。但栈上分配不能支持存在线程逃逸的变量，因为栈区是线程私有的。

**标量替换**

标量（**Scalar**）即不能再分解为更小数据的变量，原始数据类型（如Java中的基本数据类型、reference类型等）。相应的，还可继续分解的变量称为聚合量（**Aggregate** ），Java对象即典型的聚合量。将一个聚合量拆分，根据程序访问的情况，把其成员变量恢复为原始数据类型来访问，这个过程称为标量替换。对于逃逸分析确认的、不会发生方法逃逸的聚合量变量，在程序执行期间并不会真正创建该对象，而是分开创建其被调用方法使用的成员变量，这些标量会被分配在栈上，具有更高的读写性能，减少了这部分的开销。

标量替换可以看作栈上分配的一种简单实现，相应的其逃逸要求也更严格，不允许变量逃逸出方法范围。

**同步消除**

同步往往涉及到加锁解锁等操作，相对耗时。如果逃逸分析可以确定某个变量不会存在线程逃逸，即该变量的读写没有线程安全问题，那么如果存在该变量的同步措施就可以被优化掉。

方法内联和逃逸分析都是『激进的』优化策略，虽然有逃生门的设计，但方法内联是有小概率失败而消耗更多性能的；而对于逃逸分析，虽然理想情况下可以达成可观的优化，但分析的过程往往十分复杂，因为Java程序中的逃逸情况十分复杂，有可能耗费时间进行了逃逸分析但不一定得到相应的优化收益，所以直到jdk7逃逸分析才作为服务端编译器默认开启的选项。

